import os
from snakemake.io import expand


VERSION = "2.0.0-DEV-12"

pepfile: config["pepfile"]
pepschema: "schemas/pep.yaml"
include: "rules/fix.smk"

global FILTERS_APPLIED
global TBL
global READS
global REF_FASTA
global REF_FASTA_RANDOM
global CM
global SPRINZL_MODE
global SPRINZL_LABELS
global SEQ_TO_SPRINZL_FINAL


# manage snakemake includes
include: "rules/common.smk"
include: "rules/trna.smk"
include: "rules/filter.smk"
include: "rules/features.smk"
include: "rules/samtools.smk"
if READS == "fastq" and "alignment" in config:
  include: "rules/parasail.smk"
include: "rules/jacusa2.smk"
if pep.config["qutrna2"]["coords"] == "sprinzl":
  include: "rules/sec_structure.smk"
include: "rules/plot.smk"
include: "rules/info.smk"



########################################################################################################################

def target_info():
  targets = [
      "info/config.yaml",
      "info/pep.yaml",
      "info/version.txt",
      "info/opts.txt"]

  if workflow.configfiles:
    targets += [os.path.join("info/configfiles", f"{i}_{os.path.basename(cf)}") for i, cf in enumerate(workflow.configfiles, start=1)]

  return targets

def target_trna_plots():
  """Heatmap targets"""
  targets = []

  bam_types = ["final"]
  # extend bam types if desired
  if config["call_filtered"] and FILTERS_APPLIED:
    bam_types += [f"filtered-{f}" for f in FILTERS_APPLIED]

  for contrast in pep.config["qutrna2"]["contrasts"]:
    cond1 = contrast["cond1"]
    cond2 = contrast["cond2"]

    dname =  "results/plots/scores/cond1~{cond1}/cond2~{cond2}/{plot_id}/bam~{bam_type}"
    for plot in config["plots"]["heatmap"]:
      targets.extend(
        expand(dname,
          cond1=cond1, cond2=cond2,
          plot_id=plot["id"], bam_type=bam_types))

  return targets

def target_all():
  targets = []
  targets.extend(target_trna_plots())

  if READS == "fastq":
    targets.extend(target_alignment())

  targets.extend(target_read_feature_plots())

  return targets

########################################################################################################################

rule all:
  input: lambda wildcards: target_all() + target_info()

########################################################################################################################

# TODO for overview
#def target_include():
#  targets = [
#    REF_FASTA
#  ]
#  if COORDS == "sprinzl":
#    if SPRINZL_MODE == "cm":
#      targets.append(CM)
#    targets.append(SPRINZL_LABELS)
#  if READS == "fastq":
#    targets.append(REF_FASTA_RANDOM)
#    for row in TBL.itertuples():
#      targets.extend(
#        expand("data/fastq/sample~{sample}/subsample~{subsample}/{bc}.fastq.gz",
#          sample=row.sample_name,
#          subsample=row.subsample_name,
#          bc=row.base_calling))
#  if READS == "bam":
#    for row in TBL.itertuples():
#      targets.extend(
#        expand("data/fastq/sample~{sample}/subsample~{subsample}/{bc}.sorted.bam",
#          sample=row.sample_name,
#          subsample=row.subsample_name,
#          bc=row.base_calling))
#
#  return targets
#
#rule include:
#  input: target_include()

########################################################################################################################

if READS == "fastq":
  def target_alignment():
    targets = []
    for row in TBL.itertuples():
      targets.extend(
        expand("results/plots/alignment/sample~{sample}/subsample~{subsample}/{bc}/alignment_score.pdf",
          sample=row.sample_name,
          subsample=row.subsample_name,
          bc=row.base_calling))

    return targets

  rule alignment:
    input: target_alignment() + target_info()

########################################################################################################################

if pep.config["qutrna2"]["coords"] == "sprinzl":
  def target_sprinzl():
    return [
      SEQ_TO_SPRINZL_FINAL,]

  rule sprinzl:
    input: target_sprinzl() + target_info()

########################################################################################################################

def target_read_feature_plots():
  targets = []

  # default overview plots of read features
  types = ["condition", "sample", "subsample"]
  targets.extend(expand("results/plots/record_count/{type}.pdf", type=types))
  targets.extend(expand("results/plots/read_length/{type}.pdf", type=types))

  # custom read feature specific plots
  for feature in ["read_length", "record_count"]:
    for plot in config["plots"].get(feature, []):
      targets.append(f"results/plots/{feature}/custom/{plot['id']}.pdf")

  if READS == "fastq":
    targets.append("results/plots/alignment/threshold_summary.pdf")
    for plot in config["plots"].get("threshold_summary", []):
      targets.append(f"results/plots/alignment/threshold_summary/custom/{plot['id']}.pdf")

  return targets


rule read_feature_plots:
  input: target_read_feature_plots() + target_info()
